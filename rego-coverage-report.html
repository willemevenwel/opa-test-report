<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Offline Rego Viewer (no external libs)</title>
<style>
  :root{
    --bg:#f7f7f7;
    --card:#ffffff;
    --muted:#888;
    --ln-bg:#f0f0f0;
    --covered:#d8f6d8;
    --missed:#f7d8d8;
    --code-font: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", "Courier New", monospace;
  }

  body{
    font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    margin: 20px;
    background: var(--bg);
    color: #222;
  }

  h1{ margin:0 0 8px 0; font-size:18px; }
  p.help{ margin:6px 0 0 0; color:var(--muted); font-size:13px; }

  .controls{
    margin-top:12px;
    display:flex;
    gap:8px;
    align-items:center;
  }

  .viewer {
    margin-top:18px;
    background:var(--card);
    border-radius:8px;
    box-shadow: 0 4px 14px rgba(12,20,30,0.06);
    padding:14px;
  }

  .toolbar{
    display:flex;
    gap:8px;
    justify-content:flex-end;
    margin-bottom:8px;
  }

  button {
    border:1px solid #ddd;
    background:#fff;
    padding:6px 10px;
    border-radius:6px;
    cursor:pointer;
    font-size:13px;
  }
  button:active{ transform:translateY(1px); }

  .fileinfo {
    display:flex;
    gap:12px;
    align-items:center;
  }

  /* code table */
  .code-table {
    width:100%;
    border-collapse:collapse;
    font-family: var(--code-font);
    font-size:13px;
    line-height:1.45;
    overflow:auto;
  }
  .code-wrap { display:block; width:100%; overflow:auto; }

  .code-table td { vertical-align:top; padding:0; }
  .ln {
    width:60px;
    text-align:right;
    padding:8px 12px;
    background:var(--ln-bg);
    color:var(--muted);
    border-right:1px solid #e6e6e6;
    user-select: none;
    font-size:12px;
  }
  .code {
    padding:8px 12px;
    white-space:pre;
    word-break:normal;
  }

  /* token colors (simple) */
  .tok-comment { color:#6a737d; font-style:italic; }
  .tok-keyword { color:#000080; font-weight:600; }
  .tok-string { color:#008000; }
  .tok-number { color:#0b7fbf; }
  .tok-operator { color:#aa22ff; }
  .tok-builtin { color:#2b91af; }
  .tok-variable { color:#333; }
  .tok-punct { color:#444; }

  /* coverage highlights (applies to code cell td) */
  tr.covered td.code { background: var(--covered) !important; }
  tr.missed td.code { background: var(--missed) !important; }
  tr.ignored td.code { background: #e6f0ff !important; }

  /* summary table */
  .summary-table {
    border-collapse: collapse;
    margin-bottom: 12px;
    background: #fff;
  }
  .summary-table td {
    border: 1px solid #e0e0e0;
    padding: 6px 12px;
    font-size: 15px;
  }
  .summary-table tr {
    border-bottom: 1px solid #e0e0e0;
  }
  .legend {
    margin-bottom: 18px;
    font-size: 14px;
    display: flex;
    gap: 24px;
    align-items: center;
  }
  .legend-swatch {
    display: inline-block;
    width: 18px;
    height: 18px;
    border-radius: 3px;
    margin-right: 6px;
    vertical-align: middle;
    border: 1px solid #bbb;
  }
  .covered-swatch { background: #e6ffe6; border-color: #b2e6b2; }
  .uncovered-swatch { background: #ffe6e6; border-color: #e6b2b2; }
  .ignored-swatch { background: #e6f0ff; border-color: #b2cbe6; }
</style>
</head>
<body>

<h1>Offline Rego Unit Test Coverage Viewer</h1>
<p class="help">Instructions: open with a local server and pass query param: <code>?coverage=coverage.json</code>. The report will show all files in the coverage report.</p>

<div class="controls">
  <table class="summary-table" style="margin-bottom: 12px;">
    <tr>
      <td style="padding-right: 24px;"><strong>Loaded file:</strong></td>
      <td id="fileName">—</td>
      <td style="padding-right: 24px;"><strong>Total coverage:</strong></td>
      <td id="covName">—</td>
      <td style="padding-right: 24px;"><strong>Covered lines:</strong></td>
      <td id="mainCoveredLines">—</td>
      <td style="padding-right: 24px;"><strong>Not covered lines:</strong></td>
      <td id="mainNotCoveredLines">—</td>
    </tr>
  </table>
</div>
<div class="legend">
  <span><span class="legend-swatch covered-swatch"></span>Covered line</span>
  <span><span class="legend-swatch uncovered-swatch"></span>Not covered line</span>
  <span><span class="legend-swatch ignored-swatch"></span>Non-executable/ignored line</span>
</div>
<div class="viewer" id="viewer" style="display:none;">
  <div class="toolbar" id="toolbar">
    <div style="flex:1"></div>
    <div style="color:var(--muted); font-size:13px">Note: this viewer highlights coverage ranges from the JSON format you provided.</div>
  </div>

  <div class="code-wrap" id="codeWrap">
    <table class="code-table" id="codeTable"><tbody></tbody></table>
  </div>
</div>

<script>
/* ---------- Helpers ---------- */

function getQueryParam(name){
  return new URLSearchParams(window.location.search).get(name);
}
function basename(path){
  if(!path) return path;
  const parts = path.split('/');
  return parts[parts.length-1];
}
function escapeHtml(s){
  return s.replace(/[&<>"']/g, function(c){
    return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]);
  });
}

// New: List all policy files (not _test.rego) from coverage.json
async function listPolicyFiles(coveragePath) {
  try {
    const covText = await fetchTextOrThrow(coveragePath);
    const data = JSON.parse(covText);
    const files = data.files || {};
    // Only include .rego files that do NOT end with _test.rego
    return Object.keys(files).filter(f => f.endsWith('.rego') && !f.endsWith('_test.rego'));
  } catch (e) {
    alert('Could not load coverage.json: ' + e.message);
    return [];
  }
}

// New: UI for selecting and displaying all policy files
async function showPolicyFileSelector(coveragePath) {
  const files = await listPolicyFiles(coveragePath);
  const container = document.createElement('div');
  container.style.margin = '16px 0';
  container.innerHTML = '<strong>Policy file coverage:</strong>';
  // Insert before .viewer
  const viewer = document.getElementById('viewer');
  viewer.parentNode.insertBefore(container, viewer);

  // Load coverage.json once
  let covText = '';
  let covData = {};
  try {
    covText = await fetchTextOrThrow(coveragePath);
    covData = JSON.parse(covText);
  } catch (e) {}

  // Use root 'coverage' field for combined coverage
  // If the value is > 1, assume it's already a percentage
  let avgCoveragePct = '—';
  let coveredLines = 0;
  let notCoveredLines = 0;
  if (covData.coverage !== undefined) {
    avgCoveragePct = covData.coverage > 1 ? covData.coverage.toFixed(0) + '%' : (covData.coverage * 100).toFixed(0) + '%';
  }
  if (covData.covered_lines !== undefined) coveredLines = covData.covered_lines;
  if (covData.not_covered_lines !== undefined) notCoveredLines = covData.not_covered_lines;
  document.getElementById('fileName').textContent = 'All';
  let covNameElem = document.getElementById('covName');
  covNameElem.innerHTML = avgCoveragePct +
    (coveragePath ?
      ' <span style="font-size:13px;color:var(--muted);">(<a href="' + encodeURI(coveragePath) + '" target="_blank" style="color:var(--muted);text-decoration:underline;">' + basename(coveragePath) + '</a>)</span>'
      : '');
  document.getElementById('mainCoveredLines').textContent = coveredLines;
  document.getElementById('mainNotCoveredLines').textContent = notCoveredLines;

  // For each file, render its code and coverage below the selector
  for (const f of files) {
    // Collapsible container for each policy
    const collapsible = document.createElement('div');
    collapsible.style.marginBottom = '24px';
    collapsible.style.border = '1px solid #eee';
    collapsible.style.borderRadius = '6px';
    collapsible.style.background = '#fafbfc';

    // Header row with collapse/expand button, file name, and toggle button
    const headerRow = document.createElement('div');
    headerRow.style.display = 'flex';
    headerRow.style.alignItems = 'center';
    headerRow.style.margin = '0';
    headerRow.style.padding = '10px 12px';
    headerRow.style.cursor = 'pointer';
    headerRow.style.userSelect = 'none';

    // Collapse/expand icon
    const collapseIcon = document.createElement('span');
    collapseIcon.innerHTML = '<svg width="16" height="16" viewBox="0 0 16 16"><polyline points="4,6 8,10 12,6" fill="none" stroke="#888" stroke-width="2"/></svg>';
    collapseIcon.style.marginRight = '10px';
    headerRow.appendChild(collapseIcon);

    // File header
    const fileHeader = document.createElement('h2');
    fileHeader.textContent = basename(f);
    fileHeader.style.margin = '0';
    fileHeader.style.flex = '1';
    fileHeader.style.fontSize = '16px';
    headerRow.appendChild(fileHeader);

    // Toggle button for coverage highlight (eye icon)
    const toggleBtn = document.createElement('button');
    toggleBtn.innerHTML = '<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg"><title>Toggle coverage highlight on and off</title><path d="M10 4C5.45455 4 2.27273 8.18182 2.27273 10C2.27273 11.8182 5.45455 16 10 16C14.5455 16 17.7273 11.8182 17.7273 10C17.7273 8.18182 14.5455 4 10 4Z" stroke="#888" stroke-width="1.5"/><circle cx="10" cy="10" r="3" stroke="#888" stroke-width="1.5"/></svg>';
    toggleBtn.title = 'Toggle coverage highlight on and off';
    toggleBtn.setAttribute('aria-label', 'Toggle coverage highlight on and off');
    toggleBtn.style.background = 'none';
    toggleBtn.style.border = 'none';
    toggleBtn.style.cursor = 'pointer';
    toggleBtn.style.padding = '0 0 0 8px';
    toggleBtn.style.display = 'flex';
    toggleBtn.style.alignItems = 'center';
    toggleBtn.style.height = '28px';
    toggleBtn.style.marginLeft = '8px';
    headerRow.appendChild(toggleBtn);

    // Coverage percentage for this file from its 'coverage' field in coverage.json
    let pct = '';
    let fileCoveredLines = 0;
    let fileNotCoveredLines = 0;
    if (covData.files) {
      // Try to match by exact key, or by basename
      let fileEntry = covData.files[f];
      if (!fileEntry) {
        // Try to find by basename
        const base = basename(f);
        for (const key of Object.keys(covData.files)) {
          if (basename(key) === base) {
            fileEntry = covData.files[key];
            break;
          }
        }
      }
      if (fileEntry && fileEntry.coverage !== undefined) {
        pct = fileEntry.coverage > 1 ? fileEntry.coverage.toFixed(0) + '%' : (fileEntry.coverage * 100).toFixed(0) + '%';
      }
      fileCoveredLines = fileEntry && fileEntry.covered_lines !== undefined ? fileEntry.covered_lines : 0;
      fileNotCoveredLines = fileEntry && fileEntry.not_covered_lines !== undefined ? fileEntry.not_covered_lines : 0;
    }
    const pctSpan = document.createElement('span');
    pctSpan.textContent = pct;
    pctSpan.title = basename(f) + "'s coverage";
    pctSpan.style.marginLeft = '8px';
    pctSpan.style.color = 'var(--muted)';
    pctSpan.style.fontSize = '14px';
    headerRow.appendChild(pctSpan);
    // Add summary for this policy
    const fileSummary = document.createElement('span');
    fileSummary.innerHTML = `<span style='margin-left:12px;'><strong>Covered lines:</strong> ${fileCoveredLines}</span> <span style='margin-left:12px;'><strong>Not covered lines:</strong> ${fileNotCoveredLines}</span>`;
    fileSummary.style.color = 'var(--muted)';
    fileSummary.style.fontSize = '13px';
    headerRow.appendChild(fileSummary);

    collapsible.appendChild(headerRow);

    // Code viewer
    const codeWrap = document.createElement('div');
    codeWrap.className = 'code-wrap';
    codeWrap.style.margin = '0';
    const codeTable = document.createElement('table');
    codeTable.className = 'code-table';
    codeTable.innerHTML = '<tbody></tbody>';
    codeWrap.appendChild(codeTable);
    collapsible.appendChild(codeWrap);

    container.appendChild(collapsible);

    // Fetch code and coverage, then render
    try {
      const codeText = await fetchTextOrThrow(f);
      const totalLines = codeText.split(/\r?\n/).length;
      const coverageData = parseCoverageJson(covText, f, totalLines);
      // Render code table
      const tbody = codeTable.querySelector('tbody');
      tbody.innerHTML = '';
      const lines = codeText.split(/\r?\n/);
      for(let i=0;i<lines.length;i++){
        const lineNumber = i+1;
        const tr = document.createElement('tr');
        // Determine if this line should be ignored (non-executable)
        const trimmed = lines[i].trim();
        const isIgnored =
          trimmed === '' ||
          trimmed === '}' ||
          trimmed.startsWith('package ');
        if (isIgnored) {
          tr.classList.add('ignored');
        } else if(coverageData){
          if(coverageData.covered && coverageData.covered.has(lineNumber)) tr.classList.add('covered');
          else if(coverageData.missed && coverageData.missed.has(lineNumber)) tr.classList.add('missed');
        }
        const tdLn = document.createElement('td');
        tdLn.className = 'ln';
        tdLn.textContent = lineNumber;
        const tdCode = document.createElement('td');
        tdCode.className = 'code';
        tdCode.innerHTML = tokenizeRego(lines[i] || '');
        tr.appendChild(tdLn);
        tr.appendChild(tdCode);
        tbody.appendChild(tr);
      }
      // Toggle coverage highlight functionality
      let highlightOn = true;
      toggleBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        highlightOn = !highlightOn;
        const rows = codeTable.querySelectorAll('tbody tr');
        rows.forEach(r => {
          if(highlightOn){
            // reapply classes from coverageData
            const idx = Array.from(rows).indexOf(r) + 1;
            r.classList.remove('covered','missed');
            if(coverageData.covered && coverageData.covered.has(idx)) r.classList.add('covered');
            else if(coverageData.missed && coverageData.missed.has(idx)) r.classList.add('missed');
          } else {
            r.classList.remove('covered','missed');
          }
        });
      });
      // Collapse/expand functionality
      let collapsed = false;
      headerRow.addEventListener('click', () => {
        collapsed = !collapsed;
        codeWrap.style.display = collapsed ? 'none' : '';
        toggleBtn.style.display = collapsed ? 'none' : 'flex';
        pctSpan.style.display = 'inline'; // Always show percentage
        collapseIcon.innerHTML = collapsed
          ? '<svg width="16" height="16" viewBox="0 0 16 16"><polyline points="4,10 8,6 12,10" fill="none" stroke="#888" stroke-width="2"/></svg>'
          : '<svg width="16" height="16" viewBox="0 0 16 16"><polyline points="4,6 8,10 12,6" fill="none" stroke="#888" stroke-width="2"/></svg>';
      });
    } catch (e) {
      const errMsg = document.createElement('div');
      errMsg.style.color = 'red';
      errMsg.textContent = 'Error loading file: ' + f + ' — ' + e.message;
      collapsible.appendChild(errMsg);
    }
  }
}

// FIX: Define KEYWORDS and BUILTINS before tokenizeRego
const KEYWORDS = new Set(['package','import','default','else','if','then','true','false','null','not','with']);
const BUILTINS = new Set(['input','data','trace','http']); // small sample

function tokenizeRego(code){
  // global regex with alternation. 's' flag isn't universally supported in older browsers -> use [\s\S]
  const tokenRe = /\/\*[\s\S]*?\*\/|\/\/.*|"(?:\\.|[^"\\])*"|\b\d+(\.\d+)?\b|\b[A-Za-z_][A-Za-z0-9_]*\b|==|!=|<=|>=|&&|\|\||[=<>+\-*/%]|[{}()[\].,:]/g;
  let out = '';
  let lastIndex = 0;
  let m;
  while((m = tokenRe.exec(code)) !== null){
    // add plain text between tokens (should be none because regex covers many things, but keep safe)
    if(m.index > lastIndex){
      out += escapeHtml(code.substring(lastIndex, m.index));
    }
    const tok = m[0];
    let cls = '';
    if(/^\/\*/.test(tok) || /^\/\//.test(tok)){
      cls = 'tok-comment';
    } else if(/^"/.test(tok)){
      cls = 'tok-string';
    } else if(/^\d/.test(tok)){
      cls = 'tok-number';
    } else if(/^[A-Za-z_]/.test(tok)){
      if(KEYWORDS.has(tok)) cls = 'tok-keyword';
      else if(BUILTINS.has(tok)) cls = 'tok-builtin';
      else cls = 'tok-variable';
    } else if(/^(==|!=|<=|>=|&&|\|\||[=<>+\-*/%])$/.test(tok)){
      cls = 'tok-operator';
    } else {
      cls = 'tok-punct';
    }
    out += '<span class="'+cls+'">' + escapeHtml(tok) + '</span>';
    lastIndex = tokenRe.lastIndex;
  }
  if(lastIndex < code.length){
    out += escapeHtml(code.substring(lastIndex));
  }
  return out;
}

/* ---------- Coverage parsing: expand ranges like {start:{row:3},end:{row:5}} to line numbers ---------- */
function expandRangesToSet(ranges){
  const s = new Set();
  if(!Array.isArray(ranges)) return s;
  for(const r of ranges){
    if(!r || !r.start || typeof r.start.row !== 'number') continue;
    const start = r.start.row;
    const end = (r.end && typeof r.end.row === 'number') ? r.end.row : start;
    for(let i = start; i <= end; i++) s.add(i);
  }
  return s;
}

function parseCoverageJson(jsonText, targetFile, totalLines){
  let data;
  try { data = JSON.parse(jsonText); } catch(e){ throw new Error('Invalid JSON coverage file'); }
  const files = data.files || {};
  const covered = new Set();
  // attempt to match by exact key or basename match
  for(const key of Object.keys(files)){
    if(key === targetFile || key.endsWith('/' + targetFile) || basename(key) === targetFile){
      const info = files[key];
      const s = expandRangesToSet(info.covered || []);
      for(const l of s) covered.add(l);
    }
  }
  const missed = new Set();
  // mark missed = lines that exist but are not covered (you can change logic if you prefer neutral)
  for(let i=1;i<=totalLines;i++){
    if(!covered.has(i)) missed.add(i);
  }
  return {covered, missed};
}

/* ---------- Rendering ---------- */
function renderCodeTable(codeText, coverageData){
  const tbody = document.querySelector('#codeTable tbody');
  tbody.innerHTML = '';
  const lines = codeText.split(/\r?\n/);
  for(let i=0;i<lines.length;i++){
    const lineNumber = i+1;
    const tr = document.createElement('tr');
    if(coverageData){
      if(coverageData.covered && coverageData.covered.has(lineNumber)) tr.classList.add('covered');
      else if(coverageData.missed && coverageData.missed.has(lineNumber)) tr.classList.add('missed');
    }
    const tdLn = document.createElement('td');
    tdLn.className = 'ln';
    tdLn.textContent = lineNumber;

    const tdCode = document.createElement('td');
    tdCode.className = 'code';
    // highlight the single line — feed into tokenizer (tokenizeRego works on full code too)
    // We call tokenizeRego on the line (not entire file) to avoid cross-line tokenization issues
    tdCode.innerHTML = tokenizeRego(lines[i] || '');
    tr.appendChild(tdLn);
    tr.appendChild(tdCode);
    tbody.appendChild(tr);
  }
}

// --- Shared function to render a single policy file as a collapsible card ---
async function renderPolicyCard(container, f, covData, covText) {
  // Collapsible container for each policy
  const collapsible = document.createElement('div');
  collapsible.style.marginBottom = '24px';
  collapsible.style.border = '1px solid #eee';
  collapsible.style.borderRadius = '6px';
  collapsible.style.background = '#fafbfc';

  // Header row with collapse/expand button, file name, and toggle button
  const headerRow = document.createElement('div');
  headerRow.style.display = 'flex';
  headerRow.style.alignItems = 'center';
  headerRow.style.margin = '0';
  headerRow.style.padding = '10px 12px';
  headerRow.style.cursor = 'pointer';
  headerRow.style.userSelect = 'none';

  // Collapse/expand icon
  const collapseIcon = document.createElement('span');
  collapseIcon.innerHTML = '<svg width="16" height="16" viewBox="0 0 16 16"><polyline points="4,6 8,10 12,6" fill="none" stroke="#888" stroke-width="2"/></svg>';
  collapseIcon.style.marginRight = '10px';
  headerRow.appendChild(collapseIcon);

  // File header
  const fileHeader = document.createElement('h2');
  fileHeader.textContent = basename(f);
  fileHeader.style.margin = '0';
  fileHeader.style.flex = '1';
  fileHeader.style.fontSize = '16px';
  headerRow.appendChild(fileHeader);

  // Toggle button for coverage highlight (eye icon)
  const toggleBtn = document.createElement('button');
  toggleBtn.innerHTML = '<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg"><title>Toggle coverage highlight on and off</title><path d="M10 4C5.45455 4 2.27273 8.18182 2.27273 10C2.27273 11.8182 5.45455 16 10 16C14.5455 16 17.7273 11.8182 17.7273 10C17.7273 8.18182 14.5455 4 10 4Z" stroke="#888" stroke-width="1.5"/><circle cx="10" cy="10" r="3" stroke="#888" stroke-width="1.5"/></svg>';
  toggleBtn.title = 'Toggle coverage highlight on and off';
  toggleBtn.setAttribute('aria-label', 'Toggle coverage highlight on and off');
  toggleBtn.style.background = 'none';
  toggleBtn.style.border = 'none';
  toggleBtn.style.cursor = 'pointer';
  toggleBtn.style.padding = '0 0 0 8px';
  toggleBtn.style.display = 'flex';
  toggleBtn.style.alignItems = 'center';
  toggleBtn.style.height = '28px';
  toggleBtn.style.marginLeft = '8px';
  headerRow.appendChild(toggleBtn);

  // Coverage percentage for this file from its 'coverage' field in coverage.json
  let pct = '';
  let fileCoveredLines = 0;
  let fileNotCoveredLines = 0;
  if (covData.files) {
    // Try to match by exact key, or by basename
    let fileEntry = covData.files[f];
    if (!fileEntry) {
      // Try to find by basename
      const base = basename(f);
      for (const key of Object.keys(covData.files)) {
        if (basename(key) === base) {
          fileEntry = covData.files[key];
          break;
        }
      }
    }
    if (fileEntry && fileEntry.coverage !== undefined) {
      pct = fileEntry.coverage > 1 ? fileEntry.coverage.toFixed(0) + '%' : (fileEntry.coverage * 100).toFixed(0) + '%';
    }
    fileCoveredLines = fileEntry && fileEntry.covered_lines !== undefined ? fileEntry.covered_lines : 0;
    fileNotCoveredLines = fileEntry && fileEntry.not_covered_lines !== undefined ? fileEntry.not_covered_lines : 0;
  }
  const pctSpan = document.createElement('span');
  pctSpan.textContent = pct;
  pctSpan.title = basename(f) + "'s coverage";
  pctSpan.style.marginLeft = '8px';
  pctSpan.style.color = 'var(--muted)';
  pctSpan.style.fontSize = '14px';
  headerRow.appendChild(pctSpan);
  // Add summary for this policy
  const fileSummary = document.createElement('span');
  fileSummary.innerHTML = `<span style='margin-left:12px;'><strong>Covered lines:</strong> ${fileCoveredLines}</span> <span style='margin-left:12px;'><strong>Not covered lines:</strong> ${fileNotCoveredLines}</span>`;
  fileSummary.style.color = 'var(--muted)';
  fileSummary.style.fontSize = '13px';
  headerRow.appendChild(fileSummary);

  collapsible.appendChild(headerRow);

  // Code viewer
  const codeWrap = document.createElement('div');
  codeWrap.className = 'code-wrap';
  codeWrap.style.margin = '0';
  const codeTable = document.createElement('table');
  codeTable.className = 'code-table';
  codeTable.innerHTML = '<tbody></tbody>';
  codeWrap.appendChild(codeTable);
  collapsible.appendChild(codeWrap);

  container.appendChild(collapsible);

  // Fetch code and coverage, then render
  try {
    const codeText = await fetchTextOrThrow(f);
    const totalLines = codeText.split(/\r?\n/).length;
    const coverageData = parseCoverageJson(covText, f, totalLines);
    // Render code table
    const tbody = codeTable.querySelector('tbody');
    tbody.innerHTML = '';
    const lines = codeText.split(/\r?\n/);
    for(let i=0;i<lines.length;i++){
      const lineNumber = i+1;
      const tr = document.createElement('tr');
      // Determine if this line should be ignored (non-executable)
      const trimmed = lines[i].trim();
      const isIgnored =
        trimmed === '' ||
        trimmed === '}' ||
        trimmed.startsWith('package ');
      if (isIgnored) {
        tr.classList.add('ignored');
      } else if(coverageData){
        if(coverageData.covered && coverageData.covered.has(lineNumber)) tr.classList.add('covered');
        else if(coverageData.missed && coverageData.missed.has(lineNumber)) tr.classList.add('missed');
      }
      const tdLn = document.createElement('td');
      tdLn.className = 'ln';
      tdLn.textContent = lineNumber;
      const tdCode = document.createElement('td');
      tdCode.className = 'code';
      tdCode.innerHTML = tokenizeRego(lines[i] || '');
      tr.appendChild(tdLn);
      tr.appendChild(tdCode);
      tbody.appendChild(tr);
    }
    // Toggle coverage highlight functionality
    let highlightOn = true;
    toggleBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      highlightOn = !highlightOn;
      const rows = codeTable.querySelectorAll('tbody tr');
      rows.forEach(r => {
        if(highlightOn){
          // reapply classes from coverageData
          const idx = Array.from(rows).indexOf(r) + 1;
          r.classList.remove('covered','missed');
          if(coverageData.covered && coverageData.covered.has(idx)) r.classList.add('covered');
          else if(coverageData.missed && coverageData.missed.has(idx)) r.classList.add('missed');
        } else {
          r.classList.remove('covered','missed');
        }
      });
    });
    // Collapse/expand functionality
    let collapsed = false;
    headerRow.addEventListener('click', () => {
      collapsed = !collapsed;
      codeWrap.style.display = collapsed ? 'none' : '';
      toggleBtn.style.display = collapsed ? 'none' : 'flex';
      pctSpan.style.display = 'inline'; // Always show percentage
      collapseIcon.innerHTML = collapsed
        ? '<svg width="16" height="16" viewBox="0 0 16 16"><polyline points="4,10 8,6 12,10" fill="none" stroke="#888" stroke-width="2"/></svg>'
        : '<svg width="16" height="16" viewBox="0 0 16 16"><polyline points="4,6 8,10 12,6" fill="none" stroke="#888" stroke-width="2"/></svg>';
    });
  } catch (e) {
    const errMsg = document.createElement('div');
    errMsg.style.color = 'red';
    errMsg.textContent = 'Error loading file: ' + f + ' — ' + e.message;
    collapsible.appendChild(errMsg);
  }
}



/* ---------- File loading & orchestration ---------- */

async function fetchTextOrThrow(path){
  const r = await fetch(path, {cache:'no-store'});
  if(!r.ok) throw new Error(`Failed to fetch "${path}": ${r.status} ${r.statusText}`);
  return r.text();
}

let currentCodeText = '';
let currentCoverage = null;

/* ---------- UI wiring ---------- */
// Removed event listeners for reload, copy, and toggle coverage buttons

/* ---------- Auto-start ---------- */
const coverageParam = getQueryParam('coverage');
if(coverageParam){
  showPolicyFileSelector(coverageParam);
  document.getElementById('fileName').textContent = 'All';
  document.getElementById('covName').textContent = '—';
  document.getElementById('viewer').style.display = 'none';
} else {
  document.getElementById('fileName').textContent = 'none (use ?coverage=...)';
  document.getElementById('viewer').style.display = 'none';
}
</script>
</body>
</html>
